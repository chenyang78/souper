#!/usr/bin/env perl

# Copyright 2014 The Souper Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use warnings;
use strict;
use Redis;
use Getopt::Long;
use File::Temp;
use Time::HiRes;

my $need_solver = <<END;
$0 requires the SOUPER_SOLVER environment variable to be defined, e.g. as
-stp-path=/path/to/stp
END
my $solver = $ENV{"SOUPER_SOLVER"};
die $need_solver unless $solver;

my $check = "@CMAKE_BINARY_DIR@/souper-check -solver-timeout=15 ${solver}";

sub runit ($) {
    my $cmd = shift;
    my $res = (system "$cmd");
    return $? >> 8;
}

sub usage() {
    print <<'END';
Options:
  -merge       Merge optimizations that differ only in bitwidths and constants
  -noopts      Dump not-optimizations instead of optimizations
  -noparse     Do not ensure that each LHS in the cache parses as Souper
  -sort=size|sprofile|dprofile
               Sort optimizations by increasing size (default), decreasing
               static profile count, or descreasing dynamic profile count
  -raw         Dump all keys and values and exit, ignoring all other options
  -reduce      Attempt to reduce the size of each optimization
  -verify      Verify each optimization
END
    exit -1;
}

my $RAW = 0;
my $NOOPTS = 0;
my $SORT = "size";
my $REDUCE = 0;
my $MERGE = 0;
my $NOPARSE = 0;
my $VERIFY = 0;
GetOptions(
    "merge" => \$MERGE,
    "noopts" => \$NOOPTS,
    "noparse" => \$NOPARSE,
    "sort=s" => \$SORT,
    "raw"  => \$RAW,
    "reduce" => \$REDUCE,
    "verify" => \$VERIFY,
    ) or usage();
usage() unless ($SORT eq "size" || $SORT eq "sprofile" || $SORT eq "dprofile");

my $reducer = "@CMAKE_BINARY_DIR@/reduce";

my $opt_count=0;
my $noopt_count=0;
my %values;
my %sprofiles;
my %dprofiles;
my %toprint;

print "\nGrabbing Redis keys...";

my $r = Redis->new();
$r->ping || die "no server?";
my @keys = $r->keys('*');

if ($RAW) {
    foreach my $LHS (sort @keys) {
        my %h = $r->hgetall($LHS);
        print "<$LHS>\n";
        foreach my $kk (sort keys %h) {
            print "  <$kk> <$h{$kk}>\n";
        }
        my $result = $h{"result"};
        print "------------------------------------------------------\n\n";
    }
    exit 0;
}

print "\nGrabbing Redis values...";

sub parse ($$) {
    (my $LHS, my $RHS) = @_;
    (my $fh, my $tmpfn) = File::Temp::tempfile();
    print $fh $LHS;
    $fh->flush();
    my $arg;
    if ($VERIFY) {
        $arg = "--infer-rhs";
    } else {
        $arg = "--parse-lhs-only";
    }
    open INF, "${check} $arg < $tmpfn 2>/dev/null |";
    my $output = "";
    my $success = 0;
    while (my $line = <INF>) {
        $success = 1 if ($line =~ /success/);
        next if ($line =~ /^;/);
        $output .= $line;
    }
    close INF;
    close $fh;
    unlink $tmpfn;
    if ($VERIFY) {
        die "expected '$RHS' but souper-check returned '$output'" unless
            ($output eq $RHS);
    } else {
        die "'$LHS' does not parse as Souper" unless $success;
    }
}

foreach my $LHS (@keys) {
    my %h = $r->hgetall($LHS);
    my $result = $h{"result"};
    if (defined($result)) {
        parse($LHS, $result) unless $NOPARSE;
    } else {
        next;
    }
    my $sprofile = 0;
    my $dprofile = 0;
    foreach my $kk (keys %h) {
        if ($kk =~ /^sprofile /) {
            $sprofile += $h{$kk};
        }
        if ($kk =~ /^dprofile /) {
            $dprofile += $h{$kk};
        }
    }
    $LHS .= $result;
    if ($result eq "") {
        $noopt_count++;
        $toprint{$LHS} = 1 if $NOOPTS;
    } else {
        $opt_count++;
        $toprint{$LHS} = 1 if !$NOOPTS;
    }
    $sprofiles{$LHS} = $sprofile;
    $dprofiles{$LHS} = $dprofile;
}

sub replace($$) {
    (my $old, my $new) = @_;
    die if $new eq "";
    $sprofiles{$new} += $sprofiles{$old};
    $dprofiles{$new} += $dprofiles{$old};
    $toprint{$new} = 1;
    delete $toprint{$old};
}

if ($REDUCE) {
    print "\nReducing...";

    my @keys = keys %toprint;
    foreach my $LHS (@keys) {
        (my $fh1, my $fn1) = File::Temp::tempfile();
        (my $fh2, my $fn2) = File::Temp::tempfile();
        print $fh1 $LHS;
        close $fh1;
        close $fh2;
        runit ("$reducer < $fn1 > $fn2") == 0 or die;
        open INF, "<$fn2" or die;
        my $new = "";
        while (my $line = <INF>) {
            $new .= $line;
        }
        close INF;
        unlink $fn1;
        unlink $fn2;
        if ($new eq "") {
            print "can't reduce $LHS\n";
            die;
        } else {
            replace($LHS, $new);
        }
    }
}

if ($MERGE) {
    print "\nMerging...";

    my @keys = keys %toprint;
    foreach my $LHS (@keys) {
        my $new = $LHS;
        $new =~ s/:i[0-9]+//g;
        $new =~ s/ [0-9]+/ C/g;
        replace($LHS, $new);
    }
}

print "\n\n";
print "; $opt_count optimizations\n";
print "; $noopt_count not-optimizations\n";
print "\n";

sub bylen { length $a <=> length $b }
sub bysprofile { $sprofiles{$b} <=> $sprofiles{$a} }
sub bydprofile { $dprofiles{$b} <=> $dprofiles{$a} }

my $byx = \&bylen;
$byx = \&bysprofile if ($SORT eq "sprofile");
$byx = \&bydprofile if ($SORT eq "dprofile");

foreach my $LHS (sort $byx keys %toprint) {
    print "$LHS";
    print "\n";
    print "; sprofile = $sprofiles{$LHS}\n";
    print "; dprofile = $dprofiles{$LHS}\n";
    print "------------------------------------------------------\n\n";
}
